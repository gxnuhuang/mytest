/*
请说出下面的程序输出是多少？并解释为什么？注意，该程序并不会输出 “b is 20″
联想笔记本输出：-1216823296 -1217257472 -1217540096等的随机数

解释：
我们以为进入switch后，变量b会被初始化，其实并不然，因为switch-case语句会把变量b的初始化直接就跳过了。所以，程序会输出一个随机的内存值。

拟出选择题目：
A. 20
B.随机数
C.程序无法编译通过
D.以上选项都错误
*/
#if 0
#include <stdio.h>
int main()  
{      
    int a=1;      
    switch(a)      
    {   
        int b=20;          
        case 1: 
            printf("b is %d\n",b);
            break;
        default:
            printf("b is %d\n",b);
            break;
    }
    return 0;
}

#endif

/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
下面的程序看起来是正常的，使用了一个逗号表达式来做初始化。可惜这段程序是有问题的。你知道为什么呢？

解释
这个程序会得到编译出错（语法出错），逗号表达式是没错，可是在初始化和变量声明时，逗号并不是逗号表达式的意义。这点要区分，要修改上面这个程序，你需要加上括号： int a = (1,2);

拟出选择题目
根据以下代码，判断哪个选项正确
A.编译通过，输出结果为1
B.编译通过，输出结果为2
C.编译出错，修改为int a = (1,2);输出结果为1
D.编译出错，修改为int a = (1,2);输出结果为2

*/
#if 0
#include <stdio.h>
 
int main()
{
    int a = 1,2;
    printf("a : %d\n",a);
    return 0;
}
#endif

/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
下面的程序会有什么样的输出呢？
程序会输出4321，你知道为什么吗？要知道为什么，你需要知道printf的返回值是什么。printf返回值是输出的字符个数。

*/
#if 0
#include <stdio.h>
int main()
{
    int i=43;
    printf("%d\n",printf("%d",printf("%d",i)));
    return 0;
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
下面的程序会输出什么？
联想笔记本输出：
0
12
1095237632

解释
原因是：浮点数是4个字节，12.5f 转成二进制是：01000001010010000000000000000000，十六进制是：0×41480000，十进制是：1095237632。所以，第二和第三个输出相信大家也知道是为什么了。而对于第一个，为什么会输出0，我们需要了解一下float和double的内存布局，如下：

float: 1位符号位(s)、8位指数(e)，23位尾数(m,共32位)
double: 1位符号位(s)、11位指数(e)，52位尾数(m,共64位)
然后，我们还需要了解一下printf由于类型不匹配，所以，会把float直接转成double，注意，12.5的float和double的内存二进制完全不一样。别忘了x86系列CPU都是little-endian的字节序也就是说	在x86芯片下使用是的反字节序，高位字节和低位字位要反过来。所以：

float版：0×41480000 (在内存中是：00 00 48 41)
double版：0×4029000000000000 (在内存中是：00 00 00 00 00 00 29 40)
而我们的%d要求是一个4字节的int，对于double的内存布局，我们可以看到前四个字节是00，所以输出自然是0了。

这个示例向我们说明printf并不是类型安全的，这就是为什么C++要引如cout的原因了

x86系列CPU都是little-endian的字节序.
拟出选择题目
假设机器是X86芯片，使用反字节序，使用gcc编译器，那么下面的说法正确的是 A
A.程序输出0 12 1095237632
B.程序输出12 12 1095237632
C.无法编译通过，因为printf("%d\n", a);的%d与a的类型不匹配

*/
#if 0
#include <stdio.h>
int main()  
{
    float a = 12.5;
    printf("%d\n", a);
    printf("%d\n", (int)a);
    printf("%d\n", *(int *)&a);
    return 0;  
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/

/*
下面，我们再来看一个交叉编译的事情，下面的两个文件可以编译通过吗？如果可以通过，结果是什么？

解释
该程序可以编译通过，但运行时会出错。为什么呢？原因是，在另一个文件中用 extern int *arr来外部声明一个数组并不能得到实际的期望值，因为他们的类型并不匹配。所以导致指针实际并没有指向那个数组。注意：一个指向数组的指针，并不等于一个数组。修改：extern int arr[]。（参考：ISO C语言 6.5.4.2 节）
*/
#if 0
#include <stdio.h>
extern int *arr;
int main()  
{      
    arr[1] = 100;
    printf("%d\n", arr[1]);
    return 0;  
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
请问下面的程序输出什么？
联想笔记本输出 10 4 10

解释
如果你觉得输出分别是，10，4，11，那么你就错了，错在了第三个，第一个是10没有什么问题，第二个是4，也没有什么问题，因为是32位机上一个int有4个字节。但是第三个为什么输出的不是11呢？居然还是10？原因是，sizeof不是一个函数，是一个操作符，其求i++的类型的size，这是一件可以在程序运行前（编译时）完全的事情，所以，sizeof(i++)直接就被4给取代了，在运行时也就不会有了i++这个表达式。

拟出选择题目
下面说法正确的是  B
A.输出10，4，11
B.输出10，4，10
C.编译出错，错在sizeof(i++)，应将其改为sizeof(i)
*/
#if 0
#include <stdio.h>
int main()  
{
    int i;
    i = 10;
    printf("i : %d\n",i);
    printf("sizeof(i++) is: %d\n",sizeof(i++));
    printf("i : %d\n",i);
    return 0;
}
#endif 

/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
请问下面的程序的输出值是什么？
联想笔记本输出
pot[i]:1
pot[i]:8
pot[i]:64
pot[i]:1000
解释。以C/C++中，以0开头的数字都是八进制的。

拟出选择题目
请问下面的程序的输出值是什么？ c
A. 1 2 4 8
B. 1 8 64 0
C.1 8 64 1000
*/

#if 0
#include <stdio.h>
#include <stdlib.h>

#define SIZEOF(arr) (sizeof(arr)/sizeof(arr[0]))
#define PrintInt(expr) printf("%s:%d\n",#expr,(expr))

int main()
{
    /* The powers of 10 */
    int pot[] = {
                    0001,
                    0010,
                    0100, 
                    1000
                };

    int i;
    for(i=0;i<SIZEOF(pot);i++)
        PrintInt(pot[i]);
        
    return 0;
}
#endif

/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
请问下面的程序输出是什么？（绝对不是10）
输出 100
解释
问题就出在 y = y/*p;上了，我们本来想的是 y / (*p) ，然而，我们没有加入空格和括号，结果y/*p中的 /*被解释成了注释的开始。于是，这也是整个恶梦的开始

拟出选择题目
下面说法正确的是
A.程序输出10
B.程序输出100
*/

#if 0
#include <stdio.h>
#include <stdlib.h>
#define PrintInt(expr) printf("%s : %dn",#expr,(expr))

int main()  
{
    int y = 100;
    int *p;
    p = malloc(sizeof(int));
    *p = 10;
    y = y/*p; /*dividing y by *p */;
    PrintInt(y);
    return 0;
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
本题并不简单的是考前缀++或反缀++，本题主要考的是&&和||的短路求值的问题。所为短路求值：对于（条件1 && 条件2），如果“条件1”是false，那“条件2”的表达式会被忽略了。对于（条件1 || 条件2），如果“条件1”为true，而“条件2”的表达式则被忽略了。所以，输出是8
下面的输出是什么？
A.8
B.
*/
#if 0
#include <stdio.h>
int main()  
{
    int i = 6;
    if( ((++i < 7) && ( i++/6)) || (++i <= 9))
        ;
 
    printf("%d\n",i);
    return 0;
}
#endif

/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
下面的C程序是合法的吗？如果是，那么输出是什么？
输出：
Hello! how is this? super
That  is  C !
本例主要展示了一种另类的用法。下面的两种用法是相同的：

“hello”[2]
2["hello"]

如果你知道：a[i] 其实就是 *(a+i)也就是 *(i+a)，所以如果写成 i[a] 应该也不难理解了

拟出选择题目

下面说法正确的是
A 程序不合法，编译错误
B 编译正常，输出
Hello! how is this? super
That  is  C !
C 编译正常，输出乱码 
*/
#if 0
#include <stdio.h>
int main()  
{ 
    int a=3, b = 5;
 
    printf(&a["Ya!Hello! how is this? %s\n"], &b["junk/super"]);
     
    printf(&a["WHAT%c%c%c  %c%c  %c !\n"], 1["this"],
        2["beauty"],0["tool"],0["is"],3["sensitive"],4["CCCCCC"]);
         
    return 0;  
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
请问下面的程序输出什么？（假设：输入 Hello, World）
本例的输出是“Hello, Wo”，scanf中的”%[^r]“是从中作梗的东西。意思是遇到字符r就结束了

有如下代码，假设输入Hello, World，那么程序输出是 A
A Hello, Wo
B Hello, World
C 输完，enter后程序出现错误。
*/
#if 0
#include <stdio.h>
int main()  
{ 
    char dummy[80];
    printf("Enter a string:\n");
    scanf("%[^r]",dummy);
    printf("%s\n",dummy);
    return 0;
}
#endif

/*
输出5
*/
#if 0
#include <stdio.h>
int x = 5;
int main()  
{ 
  int x = 3;
  {
   // extern int x;
    printf("%d\n",x);
  }
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*

拟出选择题目
有如下代码，下面说法正确的是
A 除了pf(); 外其他几条语句都错误
B pf = &f; pf(); 正确。(****pf)(); pf = ***f; (***************f)(); 错误
C 只有(***************f)(); 错误，其他几条语句都正确
D 全部正确
*/
#if 0
#include <stdio.h>
int (*pf)(void);
int f(void)
{

   pf = &f; // 没问题
   pf = ***f; // 取址？
   pf(); // 函数指针可以调用？
   (****pf)();  // 这又是什么？
   (***************f)(); // 这个够变态了吧？
}
int main()  
{ 
  int x = 3;
  {
   // extern int x;
    printf("%d\n",x);
  }
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
初始化可能是ISO C中最难的部分了。无论是MSVC 还是GCC 都没有完全实现。GCC 可能更接近标准。在下面的代码中，i.nested.y 和i.nested.z的最终值是什么？ 答案 2和6
*/
#if 0
#include <stdio.h>

struct {
   int x;
   struct {
       int y, z;
   } nested;
} i = { .nested.y = 5, 6, .x = 1, 2 };
int main()  
{ 
  
   printf("%d %d\n",i.nested.y ,i.nested.z);

}
#endif


/*
下面这个示例是C语言的痛，main函数返回值是什么？ 1
*/
#if 0
#include <stdio.h>
typedef struct
{
  char *key;
  char *value;
} T1;

typedef struct
{
  long type;
  char *value;
} T3;

T1 a[] =
{
  {
    "",
    ((char *)&((T3) {1, (char *) 1}))
  }
};
int main() {
   T3 *pt3 = (T3*)a[0].value;
   printf("%d \n",pt3->value);
   //return pt3->value;
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
此段程序的作者希望输出数组中的所有元素，但是他却没有得到他想要的结果，是什么让程序员和计算机产生歧义？
运行上面的程序，结果是什么都没有输出，导致这个结果的原因是sizeof的返回值是一个unsinged int，为此在比较int d 和TOTAL_ELEMENTS两个值都被转换成了unsigned int来进行比较，这样就导致-1被转换成一个非常大的值，以至于for循环不满足条件。因此，如果程序员不能理解sizeof操作符返回的是一个unsigned int的话，就会产生类似如上的人机歧义。

拟出选择题目
下面的程序输出是  D
A 23 34 12 17 204 99 16
B 23 34 12 17 204 99
C 34 12 17 204 99 16
D 什么都没输出
*/
#if 0
#include <stdio.h>
#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))
int array[] = {23,34,12,17,204,99,16};
int main()
{
    int d;
 
   // for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)
    for(d=-1;d <= (7-2);d++)
        printf("%d\n",array[d+1]);
 
    return 0;
}
#endif


/*××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/
/*
结果是1，因为continue的含义是不执行循环体之后语义，而直接到循环点。明显while(false)不属于循环体。导致这段程序的歧义就是：程序员没有完全理解计算机语言中continue的含义。
拟出选择题目
下面这段程序会输出什么，为什么？
A 1
B 1到14
C 1到15
*/
#if 0
#include <stdio.h>
enum {false,true};
 
int main()
{
    int i=1;
    do
    {
        printf("%d\n",i);
        i++;
 
        if(i < 15)
            continue;
    }while(false);
 
    return 0;
}
#endif


/*
下面这段程序的输出结果是：

当然，你首先要了解##和#的用法，如果不懂的话，本题你可以直接跳过。
解答：
看到这段程序你可能会认为，这两个printf输出的同一个结果，可是答案却非如此，本题的输出是12和f(1,2)，为什么会这样呢？因为这是宏，宏的解开不象函数执行，由里带外。

*/
#if 0
#include <stdio.h>
#define f(a,b) a##b
#define g(a)   #a
#define h(a) g(a)
 
int main()
{
        printf("%s\n", h(f(1,2)));
        printf("%s\n", g(f(1,2)));
        return 0;
}
#endif


/*
你是否似曾相识？不错这个问题在酷壳之前的博文《你能做对下面这些JavaScript的题吗？》中曾今提到过，不要让两个浮点数相比较。所以本题的答案是”f is NOT 1.0″，如果你真想比较两个浮点数时，你应该按一定精度来比较，比如你一定要在本题中做比较那么你应该这么做if( (f – 1.0f)<0.1 )
*/
#include <stdio.h>
 
int main()
{
    float f=0.0f;
    int i;
 
    for(i=0;i<10;i++)
        f = f + 0.1f;
 
    if(f == 1.0f)
        printf("f is 1.0 \n");
    else
        printf("f is NOT 1.0 \n");
 
    return 0;
}
